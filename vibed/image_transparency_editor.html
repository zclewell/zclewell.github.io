<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Transparency Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Style for the active tool button */
        .tool-btn.active {
            background-color: #3b82f6; /* blue-500 */
            color: white;
            border-color: #3b82f6;
        }
        /* Custom checkerboard background for transparency visualization */
        .checkerboard {
            background-image:
                linear-gradient(45deg, #ccc 25%, transparent 25%),
                linear-gradient(-45deg, #ccc 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ccc 75%),
                linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        /* Hide the default cursor over the canvas area */
        #canvas-container {
            cursor: none;
        }
        /* The custom cursor element */
        #custom-cursor {
            position: absolute;
            border-radius: 50%;
            pointer-events: none; /* Allows clicks to pass through to the canvas */
            transform: translate(-50%, -50%); /* Centers the cursor on the mouse pointer */
            z-index: 1000;
            transition: width 0.1s ease, height 0.1s ease; /* Smooth size change */
        }
        /* Style for the brush cursor: a high-contrast circle */
        .brush-cursor-style {
            border: 1px solid white;
            box-shadow: 0 0 0 1px black; /* Creates a black outline outside the white border */
        }
        /* Style for the eraser cursor: a different high-contrast circle */
        .eraser-cursor-style {
            border: 2px dashed black;
            background-color: rgba(255, 255, 255, 0.5);
        }
        /* Style for disabled buttons */
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-5xl bg-white rounded-xl shadow-lg p-6 space-y-6">
        <header class="text-center">
            <h1 class="text-3xl font-bold text-gray-900">Image Transparency Editor</h1>
            <p class="text-gray-600 mt-1">Upload an image, paint the areas you want to remove, and download the result.</p>
        </header>

        <!-- Main controls -->
        <div class="flex flex-col md:flex-row items-center justify-center gap-4 p-4 bg-gray-50 rounded-lg border">
            <!-- File Upload -->
            <div class="flex-shrink-0">
                <label for="image-loader" class="cursor-pointer bg-blue-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-blue-600 transition-colors">
                    Upload Image
                </label>
                <input type="file" id="image-loader" class="hidden" accept="image/*"/>
            </div>

            <!-- Tools (hidden initially) -->
            <div id="tools-container" class="hidden md:flex flex-wrap items-center justify-center gap-4">
                <!-- Brush/Eraser Toggle -->
                <div class="flex items-center border border-gray-300 rounded-lg">
                    <button id="brush-btn" class="tool-btn active py-2 px-4 rounded-l-lg transition-colors">Brush</button>
                    <button id="eraser-btn" class="tool-btn py-2 px-4 rounded-r-lg border-l border-gray-300 transition-colors">Eraser</button>
                </div>

                <!-- Brush Size Slider -->
                <div class="flex items-center gap-2">
                    <label for="brush-size" class="font-medium">Size:</label>
                    <input type="range" id="brush-size" min="1" max="100" value="20" class="w-32">
                    <span id="brush-size-value" class="font-mono text-sm w-8 text-center">20</span>
                </div>
                
                <!-- Undo Button -->
                <button id="undo-btn" class="bg-yellow-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-yellow-600 transition-colors">
                    Undo
                </button>

                <!-- Download Button -->
                <button id="download-btn" class="bg-green-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-green-600 transition-colors">
                    Download PNG
                </button>
            </div>
        </div>

        <!-- Canvas Area -->
        <div id="editor-area" class="hidden">
            <p class="text-center text-gray-500 mb-2">Paint on the image to mark areas for removal.</p>
            <div id="canvas-container" class="relative w-full mx-auto border-2 border-gray-300 rounded-lg overflow-hidden" style="max-width: 800px;">
                <!-- Canvas for the checkerboard background -->
                <canvas id="bg-canvas" class="absolute top-0 left-0 w-full h-full checkerboard"></canvas>
                <!-- Canvas for the original image -->
                <canvas id="image-canvas" class="absolute top-0 left-0 w-full h-full"></canvas>
                <!-- Canvas for user drawing (the mask) with inversion effect -->
                <canvas id="drawing-canvas" class="absolute top-0 left-0 w-full h-full" style="mix-blend-mode: difference;"></canvas>
                <!-- Custom cursor element -->
                <div id="custom-cursor" class="hidden"></div>
            </div>
        </div>

        <!-- Placeholder for when no image is loaded -->
        <div id="placeholder" class="text-center py-20 border-2 border-dashed border-gray-300 rounded-lg">
            <p class="text-gray-500">Your image will appear here once uploaded.</p>
        </div>
    </div>

    <script>
        // DOM Element References
        const imageLoader = document.getElementById('image-loader');
        const toolsContainer = document.getElementById('tools-container');
        const editorArea = document.getElementById('editor-area');
        const placeholder = document.getElementById('placeholder');
        
        const bgCanvas = document.getElementById('bg-canvas');
        const imageCanvas = document.getElementById('image-canvas');
        const drawingCanvas = document.getElementById('drawing-canvas');
        const canvasContainer = document.getElementById('canvas-container');
        const customCursor = document.getElementById('custom-cursor');

        const brushBtn = document.getElementById('brush-btn');
        const eraserBtn = document.getElementById('eraser-btn');
        const brushSizeSlider = document.getElementById('brush-size');
        const brushSizeValue = document.getElementById('brush-size-value');
        const undoBtn = document.getElementById('undo-btn');
        const downloadBtn = document.getElementById('download-btn');

        // Canvas Contexts
        const bgCtx = bgCanvas.getContext('2d');
        const imageCtx = imageCanvas.getContext('2d');
        const drawingCtx = drawingCanvas.getContext('2d');

        // State variables
        let isDrawing = false;
        let currentTool = 'brush'; // 'brush' or 'eraser'
        let brushSize = 20;
        let lastX = 0;
        let lastY = 0;
        let originalImage = null;
        let history = []; // To store canvas states for undo functionality

        // --- Event Listeners ---

        imageLoader.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                originalImage = new Image();
                originalImage.onload = () => {
                    setupCanvas();
                    toolsContainer.classList.remove('hidden');
                    toolsContainer.classList.add('flex');
                    editorArea.classList.remove('hidden');
                    placeholder.style.display = 'none';
                };
                originalImage.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        brushBtn.addEventListener('click', () => {
            currentTool = 'brush';
            brushBtn.classList.add('active');
            eraserBtn.classList.remove('active');
            updateCursorStyle();
        });

        eraserBtn.addEventListener('click', () => {
            currentTool = 'eraser';
            eraserBtn.classList.add('active');
            brushBtn.classList.remove('active');
            updateCursorStyle();
        });

        brushSizeSlider.addEventListener('input', (e) => {
            brushSize = e.target.value;
            brushSizeValue.textContent = brushSize;
            updateCursorSize();
        });

        // Drawing events
        drawingCanvas.addEventListener('mousedown', startDrawing);
        drawingCanvas.addEventListener('mouseup', stopDrawing);
        drawingCanvas.addEventListener('mousemove', draw);

        // Custom cursor events
        canvasContainer.addEventListener('mousemove', (e) => {
            const rect = canvasContainer.getBoundingClientRect();
            customCursor.style.left = `${e.clientX - rect.left}px`;
            customCursor.style.top = `${e.clientY - rect.top}px`;
        });
        canvasContainer.addEventListener('mouseenter', () => customCursor.classList.remove('hidden'));
        canvasContainer.addEventListener('mouseleave', () => {
            customCursor.classList.add('hidden');
            stopDrawing(); // Stop drawing if mouse leaves canvas
        });
        
        // Touch events
        drawingCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startDrawing(e.touches[0]);
        });
        drawingCanvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopDrawing();
        });
        drawingCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            draw(e.touches[0]);
        });

        undoBtn.addEventListener('click', undoLastStroke);
        downloadBtn.addEventListener('click', downloadImage);

        // --- Functions ---

        function setupCanvas() {
            const canvasWidth = originalImage.width;
            const canvasHeight = originalImage.height;

            [bgCanvas, imageCanvas, drawingCanvas].forEach(canvas => {
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
            });
            
            canvasContainer.style.aspectRatio = canvasWidth / canvasHeight;

            imageCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            imageCtx.drawImage(originalImage, 0, 0);
            drawingCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            history = [];
            undoBtn.disabled = true;
            
            updateCursorStyle();
            updateCursorSize();
        }
        
        function saveState() {
            if (!drawingCanvas) return;
            const currentState = drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height);
            history.push(currentState);
            undoBtn.disabled = false;
        }

        function undoLastStroke() {
            if (history.length > 0) {
                history.pop();
                drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                if (history.length > 0) {
                    drawingCtx.putImageData(history[history.length - 1], 0, 0);
                } else {
                    undoBtn.disabled = true;
                }
            }
        }

        function updateCursorStyle() {
            if (currentTool === 'brush') {
                customCursor.className = 'brush-cursor-style';
            } else {
                customCursor.className = 'eraser-cursor-style';
            }
        }
        
        function updateCursorSize() {
            customCursor.style.width = `${brushSize}px`;
            customCursor.style.height = `${brushSize}px`;
        }

        function getCoordinates(e) {
            const rect = drawingCanvas.getBoundingClientRect();
            const scaleX = drawingCanvas.width / rect.width;
            const scaleY = drawingCanvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function startDrawing(e) {
            isDrawing = true;
            const coords = getCoordinates(e);
            [lastX, lastY] = [coords.x, coords.y];
        }

        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            drawingCtx.beginPath();
            saveState();
        }

        function draw(e) {
            if (!isDrawing) return;
            const coords = getCoordinates(e);
            drawingCtx.lineWidth = brushSize;
            drawingCtx.lineCap = 'round';
            drawingCtx.lineJoin = 'round';

            if (currentTool === 'brush') {
                drawingCtx.globalCompositeOperation = 'source-over';
                drawingCtx.strokeStyle = 'rgba(255, 255, 255, 1)'; 
            } else {
                drawingCtx.globalCompositeOperation = 'destination-out';
            }

            drawingCtx.beginPath();
            drawingCtx.moveTo(lastX, lastY);
            drawingCtx.lineTo(coords.x, coords.y);
            drawingCtx.stroke();
            [lastX, lastY] = [coords.x, coords.y];
        }

        function downloadImage() {
            if (!originalImage) return;
            const exportCanvas = document.createElement('canvas');
            const exportCtx = exportCanvas.getContext('2d');
            const width = originalImage.width;
            const height = originalImage.height;
            exportCanvas.width = width;
            exportCanvas.height = height;
            exportCtx.drawImage(originalImage, 0, 0);
            const imageData = exportCtx.getImageData(0, 0, width, height);
            const pixels = imageData.data;
            const maskData = drawingCtx.getImageData(0, 0, width, height).data;

            for (let i = 0; i < pixels.length; i += 4) {
                if (maskData[i + 3] > 0) {
                    pixels[i + 3] = 0;
                }
            }
            exportCtx.putImageData(imageData, 0, 0);
            const link = document.createElement('a');
            link.download = 'transparent-image.png';
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        }

        brushSizeValue.textContent = brushSizeSlider.value;
        undoBtn.disabled = true;
    </script>
</body>
</html>
